{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"clojure-lsp # A Language Server for Clojure. Taking a Cursive-like approach of statically analyzing code. homepage \u2022 features \u2022 installation \u2022 settings \u2022 clients \u2022 troubleshooting \u2022 support us Overview # The goal of this project is to bring great editing tools for Clojure to all editors. It aims to work alongside you to help you navigate, identify and fix errors, perform refactors and much more! You will get: Autocomplete Jump to definition Find references Renaming Code actions Errors Automatic ns management Refactorings Code lens Semantic tokens (syntax highlighting) Call hierarchy Contribution # Contributions to clojure-lsp are very welcome! You can open an issue or a PR and we'd love to help. Building # For building the jar manually, run lein bin to generate the embedded jar inside target folder or lein uberjar for building the standalone jar. GraalVM # Every release the native binaries (Windows, Linux and MacOS) are compiled with GraalVM and uploaded. To build a native image with GraalVM: Install the GraalVM 21.0.0 for Java 11 and set the GRAALVM_HOME to the installation dir Install native-image with $GRAALVM_HOME/bin/gu install native-image Run from clojure-lsp project root ./graalvm/native-unix-compile.sh or ./graalvm/native-windows-compile.bat . The build may take some minutes and the result will be a ./clojure-lsp native binary. Development # For clojure-lsp development, there are 3 possible ways of finding a bug or implementing a new feature: Create a test for your bug/feature, then implement the code following the test. clojure-lsp starts a NREPL server if built with lein with-profile :debug bin , with that it's possible to change the code of a running instance and see the changes on your client in real time. To get the NREPL port, you can check the /tmp/clojure-lsp.*.out log, it will print the NREPL port on server startup or you can get it via server-info custom LSP command. Build clojure-lsp with your changes and test it manually in your client, this is the slowest option, but it makes sense for final tests. For debugging purposes, there is two custom commands server-info and cursor-info . Support the project # clojure-lsp has more than 8.000 lines of code, to keep all of this working, we need to help the community on a lot of issues and implement new features. As a LSP server, this project is the base for Clojure clients like Emacs(lsp-mode), VSCode(Calva) and vim. You can help us keep going and improving it by supporting the project Special thanks to Eccentric-J for the clojure-lsp logo","title":"Overview"},{"location":"#clojure-lsp","text":"A Language Server for Clojure. Taking a Cursive-like approach of statically analyzing code. homepage \u2022 features \u2022 installation \u2022 settings \u2022 clients \u2022 troubleshooting \u2022 support us","title":"clojure-lsp"},{"location":"#overview","text":"The goal of this project is to bring great editing tools for Clojure to all editors. It aims to work alongside you to help you navigate, identify and fix errors, perform refactors and much more! You will get: Autocomplete Jump to definition Find references Renaming Code actions Errors Automatic ns management Refactorings Code lens Semantic tokens (syntax highlighting) Call hierarchy","title":"Overview"},{"location":"#contribution","text":"Contributions to clojure-lsp are very welcome! You can open an issue or a PR and we'd love to help.","title":"Contribution"},{"location":"#building","text":"For building the jar manually, run lein bin to generate the embedded jar inside target folder or lein uberjar for building the standalone jar.","title":"Building"},{"location":"#graalvm","text":"Every release the native binaries (Windows, Linux and MacOS) are compiled with GraalVM and uploaded. To build a native image with GraalVM: Install the GraalVM 21.0.0 for Java 11 and set the GRAALVM_HOME to the installation dir Install native-image with $GRAALVM_HOME/bin/gu install native-image Run from clojure-lsp project root ./graalvm/native-unix-compile.sh or ./graalvm/native-windows-compile.bat . The build may take some minutes and the result will be a ./clojure-lsp native binary.","title":"GraalVM"},{"location":"#development","text":"For clojure-lsp development, there are 3 possible ways of finding a bug or implementing a new feature: Create a test for your bug/feature, then implement the code following the test. clojure-lsp starts a NREPL server if built with lein with-profile :debug bin , with that it's possible to change the code of a running instance and see the changes on your client in real time. To get the NREPL port, you can check the /tmp/clojure-lsp.*.out log, it will print the NREPL port on server startup or you can get it via server-info custom LSP command. Build clojure-lsp with your changes and test it manually in your client, this is the slowest option, but it makes sense for final tests. For debugging purposes, there is two custom commands server-info and cursor-info .","title":"Development"},{"location":"#support-the-project","text":"clojure-lsp has more than 8.000 lines of code, to keep all of this working, we need to help the community on a lot of issues and implement new features. As a LSP server, this project is the base for Clojure clients like Emacs(lsp-mode), VSCode(Calva) and vim. You can help us keep going and improving it by supporting the project Special thanks to Eccentric-J for the clojure-lsp logo","title":"Support the project"},{"location":"CHANGELOG/","text":"Changelog # Unreleased # Allow find all references across the project of simple keywords 2021.02.14-19.46.47 # Removing false positive logs from invalid analysis from clj-kondo macro expand analysis Fix call hierarchy when the reference was not open yet in the editor. Smart re-analyze variable/function references when arguments of the definition were updated. Rollback Macos native image compress until it works for MacOS Big Sur - #322 2021.02.13-18.04.19 # Bump clj-kondo to fix false-positive unresolved-vars Prioritize project analysis on all analysis during find definition - Fixes #318 Compress native binaries with UPX decreasing binary size. 2021.02.12-03.13.12 # Fix completion issues with graalvm native linux binaries when completing local variables. Fix completion exception when completing numbers - Fixes #310 Completion inside a require suggests all available namespaces Change log pattern to /tmp/clojure-lsp.<TIMESTAMP>.out use default temp file. Should fix issues with permissions on tmp folder. 2021.02.11-12.43.06 # Fix auto add ns not working for projects. New code action: Move to let New code action: Change coll to map, list, set or vector 2021.02.10-03.01.19 # Fix config passed to clj-kondo during analysis - Fixes #308 2021.02.09-18.28.06 # Fix auto add ns to check project root and source paths Add alias on copmletion items - Fix completion items for Calva client 2021.02.07-22.51.26 # Fix install-latest-clojure-lsp.sh script - #304 Fix clojure-lsp re-analysing classpath when project contains a keyword starting with a number - #305 Allow clj-kondo to pick up config correctly in mono repos - #303 2021.02.07-03.04.31 # Make release's native binaries executable by default - #299 Improve completion removing the necessity to call completion/resolveItem - #292 New code action: Add suggested alias to namespaces - #302 2021.02.05-03.05.34 # Add support for keyword analysis (definition, references, completion, rename, hover) Reduce jar and binaries size excluding some dependencies (Need to fix a lein issue yet) 2021.02.04-02.08.58 # Fix --version on graalvm native compiled binaries 2021.02.04-01.09.21 # Add integration tests to release process 2021.02.02-14.02.23 # Fix clojure-lsp embedded jar binary during release CI Fix duplicate references on cljc files 2021.02.02-03.06.46 # Add clojure.java.io to known requires - #291 Add manual System/gc after first classpath scan, it should decrease memory after the first startup Add support for Windows GraalVM compiled native binary 2021.02.01-20.37.52 # Add native binaries for Linux and MacOS compiled with GraalVM #267 (Experimental) 2021.01.28-03.03.16 # Fix clj-kondo batch analysis when merging batchs - Fix #284 2021.01.27-21.47.42 # Fix missing printlng and avoid errors for next time (this was causing issues in clients like vim coc) 2021.01.26-22.35.27 # Fix document-symbol after #261 - Fixes #276 Reduce memory usage on startup batch analyzing classpath via clj-kondo. - Fixes #268 2021.01.25-22.56.05 # Do not remove document on textDocument/didClose , related to #264. Fix default project-specs for shadow-cljs to use npx prefix. Fix range of textDocument/hover for definition usages. Fix completionItem/resolve broken after #261. 2021.01.25-17.22.05 # Remove references code-lens from deftest forms Fix completion for alias ns from external deps - Fixes #269 2021.01.22-13.04.28 # Huge refactor https://github.com/clojure-lsp/clojure-lsp/pull/261 which uses clj-kondo analysis / findings output to almost all clojure-lsp features. Should significantly increase performance and startup time Should fix almost all bugs/issues with windows Users since we now rely on clj-kondo analysis Remove all lint configs from clojure-lsp including macro-defs , they should be configured on clj-kondo side now via .clj-kondo/config.edn Move file path on documentation to bottom 2021.01.20-01.39.32 # Fixes args for extract-function refactoring - Fixes #263 2021.01.16-03.28.20 # Check for defintions when finding references with includeDeclaration as true - Fixes #260 Add custom command cursor-info to debugging clojure-lsp. Fix unnecessary new-lines on imports when executing clean-ns 2021.01.14-23.15.54 # Check for the whole line to add-miising-* code actions instead of expect the cursor at the ns to be required/imported - Fixes #258 Return all possible add-missing-* code actions to the same line. 2021.01.14-17.19.10 # Fix add missing import code actions after refactor 2021.01.14-12.44.42 # Fixes #208 2021.01.14-02.30.28 # LSP 3.16: Add support for codeAction/resolve improving performance if client supports it Bump extend lib [CI] Remove auto release, next releases should contain more than one PR/fix","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"Allow find all references across the project of simple keywords","title":"Unreleased"},{"location":"CHANGELOG/#20210214-194647","text":"Removing false positive logs from invalid analysis from clj-kondo macro expand analysis Fix call hierarchy when the reference was not open yet in the editor. Smart re-analyze variable/function references when arguments of the definition were updated. Rollback Macos native image compress until it works for MacOS Big Sur - #322","title":"2021.02.14-19.46.47"},{"location":"CHANGELOG/#20210213-180419","text":"Bump clj-kondo to fix false-positive unresolved-vars Prioritize project analysis on all analysis during find definition - Fixes #318 Compress native binaries with UPX decreasing binary size.","title":"2021.02.13-18.04.19"},{"location":"CHANGELOG/#20210212-031312","text":"Fix completion issues with graalvm native linux binaries when completing local variables. Fix completion exception when completing numbers - Fixes #310 Completion inside a require suggests all available namespaces Change log pattern to /tmp/clojure-lsp.<TIMESTAMP>.out use default temp file. Should fix issues with permissions on tmp folder.","title":"2021.02.12-03.13.12"},{"location":"CHANGELOG/#20210211-124306","text":"Fix auto add ns not working for projects. New code action: Move to let New code action: Change coll to map, list, set or vector","title":"2021.02.11-12.43.06"},{"location":"CHANGELOG/#20210210-030119","text":"Fix config passed to clj-kondo during analysis - Fixes #308","title":"2021.02.10-03.01.19"},{"location":"CHANGELOG/#20210209-182806","text":"Fix auto add ns to check project root and source paths Add alias on copmletion items - Fix completion items for Calva client","title":"2021.02.09-18.28.06"},{"location":"CHANGELOG/#20210207-225126","text":"Fix install-latest-clojure-lsp.sh script - #304 Fix clojure-lsp re-analysing classpath when project contains a keyword starting with a number - #305 Allow clj-kondo to pick up config correctly in mono repos - #303","title":"2021.02.07-22.51.26"},{"location":"CHANGELOG/#20210207-030431","text":"Make release's native binaries executable by default - #299 Improve completion removing the necessity to call completion/resolveItem - #292 New code action: Add suggested alias to namespaces - #302","title":"2021.02.07-03.04.31"},{"location":"CHANGELOG/#20210205-030534","text":"Add support for keyword analysis (definition, references, completion, rename, hover) Reduce jar and binaries size excluding some dependencies (Need to fix a lein issue yet)","title":"2021.02.05-03.05.34"},{"location":"CHANGELOG/#20210204-020858","text":"Fix --version on graalvm native compiled binaries","title":"2021.02.04-02.08.58"},{"location":"CHANGELOG/#20210204-010921","text":"Add integration tests to release process","title":"2021.02.04-01.09.21"},{"location":"CHANGELOG/#20210202-140223","text":"Fix clojure-lsp embedded jar binary during release CI Fix duplicate references on cljc files","title":"2021.02.02-14.02.23"},{"location":"CHANGELOG/#20210202-030646","text":"Add clojure.java.io to known requires - #291 Add manual System/gc after first classpath scan, it should decrease memory after the first startup Add support for Windows GraalVM compiled native binary","title":"2021.02.02-03.06.46"},{"location":"CHANGELOG/#20210201-203752","text":"Add native binaries for Linux and MacOS compiled with GraalVM #267 (Experimental)","title":"2021.02.01-20.37.52"},{"location":"CHANGELOG/#20210128-030316","text":"Fix clj-kondo batch analysis when merging batchs - Fix #284","title":"2021.01.28-03.03.16"},{"location":"CHANGELOG/#20210127-214742","text":"Fix missing printlng and avoid errors for next time (this was causing issues in clients like vim coc)","title":"2021.01.27-21.47.42"},{"location":"CHANGELOG/#20210126-223527","text":"Fix document-symbol after #261 - Fixes #276 Reduce memory usage on startup batch analyzing classpath via clj-kondo. - Fixes #268","title":"2021.01.26-22.35.27"},{"location":"CHANGELOG/#20210125-225605","text":"Do not remove document on textDocument/didClose , related to #264. Fix default project-specs for shadow-cljs to use npx prefix. Fix range of textDocument/hover for definition usages. Fix completionItem/resolve broken after #261.","title":"2021.01.25-22.56.05"},{"location":"CHANGELOG/#20210125-172205","text":"Remove references code-lens from deftest forms Fix completion for alias ns from external deps - Fixes #269","title":"2021.01.25-17.22.05"},{"location":"CHANGELOG/#20210122-130428","text":"Huge refactor https://github.com/clojure-lsp/clojure-lsp/pull/261 which uses clj-kondo analysis / findings output to almost all clojure-lsp features. Should significantly increase performance and startup time Should fix almost all bugs/issues with windows Users since we now rely on clj-kondo analysis Remove all lint configs from clojure-lsp including macro-defs , they should be configured on clj-kondo side now via .clj-kondo/config.edn Move file path on documentation to bottom","title":"2021.01.22-13.04.28"},{"location":"CHANGELOG/#20210120-013932","text":"Fixes args for extract-function refactoring - Fixes #263","title":"2021.01.20-01.39.32"},{"location":"CHANGELOG/#20210116-032820","text":"Check for defintions when finding references with includeDeclaration as true - Fixes #260 Add custom command cursor-info to debugging clojure-lsp. Fix unnecessary new-lines on imports when executing clean-ns","title":"2021.01.16-03.28.20"},{"location":"CHANGELOG/#20210114-231554","text":"Check for the whole line to add-miising-* code actions instead of expect the cursor at the ns to be required/imported - Fixes #258 Return all possible add-missing-* code actions to the same line.","title":"2021.01.14-23.15.54"},{"location":"CHANGELOG/#20210114-171910","text":"Fix add missing import code actions after refactor","title":"2021.01.14-17.19.10"},{"location":"CHANGELOG/#20210114-124442","text":"Fixes #208","title":"2021.01.14-12.44.42"},{"location":"CHANGELOG/#20210114-023028","text":"LSP 3.16: Add support for codeAction/resolve improving performance if client supports it Bump extend lib [CI] Remove auto release, next releases should contain more than one PR/fix","title":"2021.01.14-02.30.28"},{"location":"capabilities/","text":"Capabilities # Implementation Status # Below are all the currently supported LSP capabilities and their implementation status: capability done notes initialize \u221a initialized \u221a shutdown \u221a exit \u221a $/cancelRequest $/progress window/showMessage \u221a window/showMessageRequest window/logMessage window/workDoneProgress/create window/workDoneProgress/cancel telemetry/event client/registerCapability \u221a client/unregisterCapability workspace/workspaceFolders workspace/didChangeWorkspaceFolders workspace/didChangeConfiguration \u221a Currently does nothing but log workspace/configuration workspace/didChangeWatchedFiles \u221a workspace/symbol \u221a workspace/executeCommand \u221a See Extra capabilities workspace/applyEdit \u221a TextDocumentEdit and RenameFile only textDocument/didOpen \u221a textDocument/didChange \u221a textDocument/willSave textDocument/willSaveWaitUntil textDocument/didSave \u221a Do nothing currently textDocument/didClose \u221a textDocument/publishDiagnostics \u221a textDocument/completion \u221a completionItem/resolve \u221a textDocument/hover \u221a textDocument/signatureHelp X Implemented hard coded textDocument/declaration textDocument/definition \u221a TODO: Find java classes definition textDocument/typeDefinition textDocument/implementation textDocument/references \u221a textDocument/documentHighlight \u221a textDocument/documentSymbol \u221a textDocument/codeAction \u221a codeAction/resolve \u221a textDocument/codeLens \u221a codeLens/resolve \u221a textDocument/documentLink documentLink/resolve textDocument/documentColor textDocument/colorPresentation textDocument/formatting \u221a textDocument/rangeFormatting \u221a textDocument/onTypeFormatting textDocument/rename \u221a textDocument/prepareRename textDocument/foldingRange textDocument/selectionRange textDocument/semanticTokens/full \u221a Just functions , type' and macros ATM textDocument/semanticTokens/full/delta textDocument/semanticTokens/range \u221a workspace/semanticTokens/refresh textDocument/linkedEditingRange textDocument/prepareCallHierarchy \u221a callHierarchy/incomingCalls \u221a callHierarchy/outgoingCalls textDocument/moniker Extra capabilities # Besides LSP official capabilities, clojure-lsp has some extra features: Refactorings # It should be possible to introduce most of the refactorings here More details # Calling executeCommand with the following commands and additional args will notify the client with applyEdit . All commands expect the first three args to be [document-uri, line, column] (eg [\"file:///home/snoe/file.clj\", 13, 11] ) done command args notes \u221a add-import-to-namespace [document-uri, line, column, import-name] \u221a add-missing-libspec \u221a clean-ns :require sort and remove unused \u221a cycle-coll \u221a cycle-privacy \u221a expand-let \u221a extract-function [document-uri, line, column, function-name] \u221a inline-symbol \u221a introduce-let [document-uri, line, column, binding-name] \u221a move-to-let [document-uri, line, column, binding-name] \u221a thread-first \u221a thread-first-all \u221a thread-last \u221a thread-last-all \u221a unwind-all \u221a unwind-thread See Vim client section for an example. Emacs provides all those refactorings via lsp-mode with the lsp-clojure- prefix. Other clients might provide a higher level interface to workspace/executeCommand you need to pass the path, line and column numbers. Custom commands # clojure-lsp has some custom commands: command args notes server-info Use to retrieve server and configuration information cursor-info [document-uri, line, column] Use to retrieve debugging information for the symbol at cursor","title":"Capabilities"},{"location":"capabilities/#capabilities","text":"","title":"Capabilities"},{"location":"capabilities/#implementation-status","text":"Below are all the currently supported LSP capabilities and their implementation status: capability done notes initialize \u221a initialized \u221a shutdown \u221a exit \u221a $/cancelRequest $/progress window/showMessage \u221a window/showMessageRequest window/logMessage window/workDoneProgress/create window/workDoneProgress/cancel telemetry/event client/registerCapability \u221a client/unregisterCapability workspace/workspaceFolders workspace/didChangeWorkspaceFolders workspace/didChangeConfiguration \u221a Currently does nothing but log workspace/configuration workspace/didChangeWatchedFiles \u221a workspace/symbol \u221a workspace/executeCommand \u221a See Extra capabilities workspace/applyEdit \u221a TextDocumentEdit and RenameFile only textDocument/didOpen \u221a textDocument/didChange \u221a textDocument/willSave textDocument/willSaveWaitUntil textDocument/didSave \u221a Do nothing currently textDocument/didClose \u221a textDocument/publishDiagnostics \u221a textDocument/completion \u221a completionItem/resolve \u221a textDocument/hover \u221a textDocument/signatureHelp X Implemented hard coded textDocument/declaration textDocument/definition \u221a TODO: Find java classes definition textDocument/typeDefinition textDocument/implementation textDocument/references \u221a textDocument/documentHighlight \u221a textDocument/documentSymbol \u221a textDocument/codeAction \u221a codeAction/resolve \u221a textDocument/codeLens \u221a codeLens/resolve \u221a textDocument/documentLink documentLink/resolve textDocument/documentColor textDocument/colorPresentation textDocument/formatting \u221a textDocument/rangeFormatting \u221a textDocument/onTypeFormatting textDocument/rename \u221a textDocument/prepareRename textDocument/foldingRange textDocument/selectionRange textDocument/semanticTokens/full \u221a Just functions , type' and macros ATM textDocument/semanticTokens/full/delta textDocument/semanticTokens/range \u221a workspace/semanticTokens/refresh textDocument/linkedEditingRange textDocument/prepareCallHierarchy \u221a callHierarchy/incomingCalls \u221a callHierarchy/outgoingCalls textDocument/moniker","title":"Implementation Status"},{"location":"capabilities/#extra-capabilities","text":"Besides LSP official capabilities, clojure-lsp has some extra features:","title":"Extra capabilities"},{"location":"capabilities/#refactorings","text":"It should be possible to introduce most of the refactorings here","title":"Refactorings"},{"location":"capabilities/#more-details","text":"Calling executeCommand with the following commands and additional args will notify the client with applyEdit . All commands expect the first three args to be [document-uri, line, column] (eg [\"file:///home/snoe/file.clj\", 13, 11] ) done command args notes \u221a add-import-to-namespace [document-uri, line, column, import-name] \u221a add-missing-libspec \u221a clean-ns :require sort and remove unused \u221a cycle-coll \u221a cycle-privacy \u221a expand-let \u221a extract-function [document-uri, line, column, function-name] \u221a inline-symbol \u221a introduce-let [document-uri, line, column, binding-name] \u221a move-to-let [document-uri, line, column, binding-name] \u221a thread-first \u221a thread-first-all \u221a thread-last \u221a thread-last-all \u221a unwind-all \u221a unwind-thread See Vim client section for an example. Emacs provides all those refactorings via lsp-mode with the lsp-clojure- prefix. Other clients might provide a higher level interface to workspace/executeCommand you need to pass the path, line and column numbers.","title":"More details"},{"location":"capabilities/#custom-commands","text":"clojure-lsp has some custom commands: command args notes server-info Use to retrieve server and configuration information cursor-info [document-uri, line, column] Use to retrieve debugging information for the symbol at cursor","title":"Custom commands"},{"location":"clients/","text":"Clients # Clients are either editors with built in LSP support like Oni, or an appropriate plugin. Clients are responsible for launching the server, the server is a subprocess of your editor not a daemon. In general, make sure to configure the client to use stdio and a server launch command like ['/usr/local/bin/clojure-lsp'] . If that fails, you may need to have your client launch inside a shell, so use someting like ['bash', '-c', '/usr/local/bin/clojure-lsp'] . In windows you probably need to rename to clojure-lsp.bat . Vim # I prefer https://github.com/neoclide/coc.nvim but both http://github.com/autozimu/LanguageClient-neovim and https://github.com/prabirshrestha/vim-lsp work well. See my nvim/init.vim and coc-settings.json LanguageClient-neovim can be configure with: Refactorings: function ! Expand ( exp ) abort let l :result = expand ( a :exp ) return l :result == # '' ? '' : \"file://\" . l :result endfunction nnoremap < silent > crcc : call LanguageClient#workspace_executeCommand ( 'cycle-coll' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crth : call LanguageClient#workspace_executeCommand ( 'thread-first' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtt : call LanguageClient#workspace_executeCommand ( 'thread-last' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtf : call LanguageClient#workspace_executeCommand ( 'thread-first-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtl : call LanguageClient#workspace_executeCommand ( 'thread-last-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crml : call LanguageClient#workspace_executeCommand ( 'move-to-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > cril : call LanguageClient#workspace_executeCommand ( 'introduce-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > crel : call LanguageClient#workspace_executeCommand ( 'expand-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > cram : call LanguageClient#workspace_executeCommand ( 'add-missing-libspec' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > initializationOptions can be sent by setting: let g:LanguageClient_settingsPath=\".lsp/settings.json\" Project-local .lsp/settings.json would have content like: { \"initializationOptions\" : { \"source-paths\" : [ \"shared-src\" , \"src\" , \"test\" , \"dashboard/src\" ] , \"macro-defs\" : { \"project.macros/dofor\" : [ \"bindings\" , \"bound-elements\" ]}}} Further refactoring mappings include being able to invoke the (coc-codeaction-*) function to provide actions such as move to let , change coll to map and so on. nmap <silent> <Leader>cr <Plug>(coc-rename) nmap <silent> <Leader>cf <Plug>(coc-references) xmap <silent> <Leader>c <Plug>(coc-codeaction-selected) nmap <silent> <Leader>c <Plug>(coc-codeaction-line) nmap <silent> gd <Plug>(coc-definition) Emacs # lsp-mode has built in support for clojure-lsp . With use-package , add the following to your emacs config: ( use-package lsp-mode :ensure t :hook (( clojure-mode . lsp ) ( clojurec-mode . lsp ) ( clojurescript-mode . lsp )) :config ;; add paths to your local installation of project mgmt tools, like lein ( setenv \"PATH\" ( concat \"/usr/local/bin\" path-separator ( getenv \"PATH\" ))) ( dolist ( m ' ( clojure-mode clojurec-mode clojurescript-mode clojurex-mode )) ( add-to-list 'lsp-language-id-configuration ` ( , m . \"clojure\" ))) ( setq lsp-clojure-server-command ' ( \"bash\" \"-c\" \"clojure-lsp\" ))) ;; Optional: In case `clojure-lsp` is not in your PATH Optionally you can add lsp-ui for UI feedback and company-mode for completion: ( use-package lsp-ui :ensure t :commands lsp-ui-mode ) ( use-package company-lsp :ensure t :commands company-lsp ) In lsp-mode , lsp-clojure-server-command variable is available to override the command to start the clojure-lsp server, might be necessary to do this on a Windows environment. For a detailed guide on how to configure Emacs with LSP, check here For more lsp-mode clojure settings, check here Oni # Seems to work reasonably well but couldn't get rename to work reliably https://github.com/onivim/oni Intellij / Cursive # https://github.com/gtache/intellij-lsp tested only briefly. Visual Studio Code # Proof of concept: in the client-vscode directory in this repo. Calva extension includes clojure-lsp support. Atom # I tried making a client but my hello world attempt didn't seem to work. If someone wants to take this on, I'd be willing to package it here too.","title":"Clients"},{"location":"clients/#clients","text":"Clients are either editors with built in LSP support like Oni, or an appropriate plugin. Clients are responsible for launching the server, the server is a subprocess of your editor not a daemon. In general, make sure to configure the client to use stdio and a server launch command like ['/usr/local/bin/clojure-lsp'] . If that fails, you may need to have your client launch inside a shell, so use someting like ['bash', '-c', '/usr/local/bin/clojure-lsp'] . In windows you probably need to rename to clojure-lsp.bat .","title":"Clients"},{"location":"clients/#vim","text":"I prefer https://github.com/neoclide/coc.nvim but both http://github.com/autozimu/LanguageClient-neovim and https://github.com/prabirshrestha/vim-lsp work well. See my nvim/init.vim and coc-settings.json LanguageClient-neovim can be configure with: Refactorings: function ! Expand ( exp ) abort let l :result = expand ( a :exp ) return l :result == # '' ? '' : \"file://\" . l :result endfunction nnoremap < silent > crcc : call LanguageClient#workspace_executeCommand ( 'cycle-coll' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crth : call LanguageClient#workspace_executeCommand ( 'thread-first' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtt : call LanguageClient#workspace_executeCommand ( 'thread-last' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtf : call LanguageClient#workspace_executeCommand ( 'thread-first-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtl : call LanguageClient#workspace_executeCommand ( 'thread-last-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crml : call LanguageClient#workspace_executeCommand ( 'move-to-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > cril : call LanguageClient#workspace_executeCommand ( 'introduce-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > crel : call LanguageClient#workspace_executeCommand ( 'expand-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > cram : call LanguageClient#workspace_executeCommand ( 'add-missing-libspec' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > initializationOptions can be sent by setting: let g:LanguageClient_settingsPath=\".lsp/settings.json\" Project-local .lsp/settings.json would have content like: { \"initializationOptions\" : { \"source-paths\" : [ \"shared-src\" , \"src\" , \"test\" , \"dashboard/src\" ] , \"macro-defs\" : { \"project.macros/dofor\" : [ \"bindings\" , \"bound-elements\" ]}}} Further refactoring mappings include being able to invoke the (coc-codeaction-*) function to provide actions such as move to let , change coll to map and so on. nmap <silent> <Leader>cr <Plug>(coc-rename) nmap <silent> <Leader>cf <Plug>(coc-references) xmap <silent> <Leader>c <Plug>(coc-codeaction-selected) nmap <silent> <Leader>c <Plug>(coc-codeaction-line) nmap <silent> gd <Plug>(coc-definition)","title":"Vim"},{"location":"clients/#emacs","text":"lsp-mode has built in support for clojure-lsp . With use-package , add the following to your emacs config: ( use-package lsp-mode :ensure t :hook (( clojure-mode . lsp ) ( clojurec-mode . lsp ) ( clojurescript-mode . lsp )) :config ;; add paths to your local installation of project mgmt tools, like lein ( setenv \"PATH\" ( concat \"/usr/local/bin\" path-separator ( getenv \"PATH\" ))) ( dolist ( m ' ( clojure-mode clojurec-mode clojurescript-mode clojurex-mode )) ( add-to-list 'lsp-language-id-configuration ` ( , m . \"clojure\" ))) ( setq lsp-clojure-server-command ' ( \"bash\" \"-c\" \"clojure-lsp\" ))) ;; Optional: In case `clojure-lsp` is not in your PATH Optionally you can add lsp-ui for UI feedback and company-mode for completion: ( use-package lsp-ui :ensure t :commands lsp-ui-mode ) ( use-package company-lsp :ensure t :commands company-lsp ) In lsp-mode , lsp-clojure-server-command variable is available to override the command to start the clojure-lsp server, might be necessary to do this on a Windows environment. For a detailed guide on how to configure Emacs with LSP, check here For more lsp-mode clojure settings, check here","title":"Emacs"},{"location":"clients/#oni","text":"Seems to work reasonably well but couldn't get rename to work reliably https://github.com/onivim/oni","title":"Oni"},{"location":"clients/#intellij-cursive","text":"https://github.com/gtache/intellij-lsp tested only briefly.","title":"Intellij / Cursive"},{"location":"clients/#visual-studio-code","text":"Proof of concept: in the client-vscode directory in this repo. Calva extension includes clojure-lsp support.","title":"Visual Studio Code"},{"location":"clients/#atom","text":"I tried making a client but my hello world attempt didn't seem to work. If someone wants to take this on, I'd be willing to package it here too.","title":"Atom"},{"location":"features/","text":"Features # Above you can find all available features that clojure-lsp provide with examples using Emacs lsp-mode client. Find a function/var definition # Find all references of a function, var, keyword or namespace alias # Show all workspace/project symbols # Show all symbols on current file # Rename symbols # Cursor hover showing symbol usages # Code actions # Name Example Clean namespace require/imports Inline symbol Extract function Add missing require Add known common require Add known common import Add suggested alias require Move to let Change coll to map,vector,set,list Code lenses showing symbol references # Format a whole file or range # Semantic tokens # Experimental: apply color on client editor for each known token Call hierarchy (Incoming only) # Execute command # Commands that client can request. Some code actions use these commands as actions. Refactoring # Commands that change/refactor the code, most of them are available via code actions. Add import to namespace # Add missing namespace (available via code actions too) # Extract Function (available via code actions too) # Inline Symbol (available via code actions too) # Clean namespace (available via code actions too) # Cycle privacy of def/defn # Cycle collection (#{}, {}, [], ()) # Change collection to {}, (), #{}, [] # Expand let # Introduce let # Move expression to let # Thread first expression # Thread last expression # Thread first all # Thread last all # Unwind all # Unwind thread # Dev # Server information # Return basic information about the server. Cursor information # Return debug information about the element at point. Custom message to client during any server process # During some process, clojure-lsp send messages to client informing some proccess, warning or error.","title":"Features"},{"location":"features/#features","text":"Above you can find all available features that clojure-lsp provide with examples using Emacs lsp-mode client.","title":"Features"},{"location":"features/#find-a-functionvar-definition","text":"","title":"Find a function/var definition"},{"location":"features/#find-all-references-of-a-function-var-keyword-or-namespace-alias","text":"","title":"Find all references of a function, var, keyword or namespace alias"},{"location":"features/#show-all-workspaceproject-symbols","text":"","title":"Show all workspace/project symbols"},{"location":"features/#show-all-symbols-on-current-file","text":"","title":"Show all symbols on current file"},{"location":"features/#rename-symbols","text":"","title":"Rename symbols"},{"location":"features/#cursor-hover-showing-symbol-usages","text":"","title":"Cursor hover showing symbol usages"},{"location":"features/#code-actions","text":"Name Example Clean namespace require/imports Inline symbol Extract function Add missing require Add known common require Add known common import Add suggested alias require Move to let Change coll to map,vector,set,list","title":"Code actions"},{"location":"features/#code-lenses-showing-symbol-references","text":"","title":"Code lenses showing symbol references"},{"location":"features/#format-a-whole-file-or-range","text":"","title":"Format a whole file or range"},{"location":"features/#semantic-tokens","text":"Experimental: apply color on client editor for each known token","title":"Semantic tokens"},{"location":"features/#call-hierarchy-incoming-only","text":"","title":"Call hierarchy (Incoming only)"},{"location":"features/#execute-command","text":"Commands that client can request. Some code actions use these commands as actions.","title":"Execute command"},{"location":"features/#refactoring","text":"Commands that change/refactor the code, most of them are available via code actions.","title":"Refactoring"},{"location":"features/#add-import-to-namespace","text":"","title":"Add import to namespace"},{"location":"features/#add-missing-namespace-available-via-code-actions-too","text":"","title":"Add missing namespace (available via code actions too)"},{"location":"features/#extract-function-available-via-code-actions-too","text":"","title":"Extract Function (available via code actions too)"},{"location":"features/#inline-symbol-available-via-code-actions-too","text":"","title":"Inline Symbol (available via code actions too)"},{"location":"features/#clean-namespace-available-via-code-actions-too","text":"","title":"Clean namespace (available via code actions too)"},{"location":"features/#cycle-privacy-of-defdefn","text":"","title":"Cycle privacy of def/defn"},{"location":"features/#cycle-collection","text":"","title":"Cycle collection (#{}, {}, [], ())"},{"location":"features/#change-collection-to","text":"","title":"Change collection to {}, (), #{}, []"},{"location":"features/#expand-let","text":"","title":"Expand let"},{"location":"features/#introduce-let","text":"","title":"Introduce let"},{"location":"features/#move-expression-to-let","text":"","title":"Move expression to let"},{"location":"features/#thread-first-expression","text":"","title":"Thread first expression"},{"location":"features/#thread-last-expression","text":"","title":"Thread last expression"},{"location":"features/#thread-first-all","text":"","title":"Thread first all"},{"location":"features/#thread-last-all","text":"","title":"Thread last all"},{"location":"features/#unwind-all","text":"","title":"Unwind all"},{"location":"features/#unwind-thread","text":"","title":"Unwind thread"},{"location":"features/#dev","text":"","title":"Dev"},{"location":"features/#server-information","text":"Return basic information about the server.","title":"Server information"},{"location":"features/#cursor-information","text":"Return debug information about the element at point.","title":"Cursor information"},{"location":"features/#custom-message-to-client-during-any-server-process","text":"During some process, clojure-lsp send messages to client informing some proccess, warning or error.","title":"Custom message to client during any server process"},{"location":"installation/","text":"Installation # Below are all available clojure-lsp installation methods, after installed, follow the documentation for your editor's language client. See Clients . Native binary (recommended) # clojure-lsp builds using GraalVM a native executable for each OS: Linux, MacOS and Windows. Manually # The binaries are available on Github releases as clojure-lsp-native-<os>-<arch>.zip , after downloading you just need to unzip it. Script # You can install it running ./install-latest-clojure-lsp.sh Embedded jar (Legacy executable) # In Github releases you will find a clojure-lsp file that runs a embedded jar. This should be removed soon, use GraalVM binaries instead. You need java on your $PATH. Grab the latest clojure-lsp from github LATEST Place it in your $PATH with a chmod 755 Nix # clojure-lsp is available in the nixpkgs : nix-shell -p clojure-lsp Windows # clojure-lsp is available as a native executable in the Clojure Scoop bucket . You need to install Scoop if you don't have it already. Issue following command to download the clojure-lsp executable. scoop install clojure-lsp","title":"Installation"},{"location":"installation/#installation","text":"Below are all available clojure-lsp installation methods, after installed, follow the documentation for your editor's language client. See Clients .","title":"Installation"},{"location":"installation/#native-binary-recommended","text":"clojure-lsp builds using GraalVM a native executable for each OS: Linux, MacOS and Windows.","title":"Native binary (recommended)"},{"location":"installation/#manually","text":"The binaries are available on Github releases as clojure-lsp-native-<os>-<arch>.zip , after downloading you just need to unzip it.","title":"Manually"},{"location":"installation/#script","text":"You can install it running ./install-latest-clojure-lsp.sh","title":"Script"},{"location":"installation/#embedded-jar-legacy-executable","text":"In Github releases you will find a clojure-lsp file that runs a embedded jar. This should be removed soon, use GraalVM binaries instead. You need java on your $PATH. Grab the latest clojure-lsp from github LATEST Place it in your $PATH with a chmod 755","title":"Embedded jar (Legacy executable)"},{"location":"installation/#nix","text":"clojure-lsp is available in the nixpkgs : nix-shell -p clojure-lsp","title":"Nix"},{"location":"installation/#windows","text":"clojure-lsp is available as a native executable in the Clojure Scoop bucket . You need to install Scoop if you don't have it already. Issue following command to download the clojure-lsp executable. scoop install clojure-lsp","title":"Windows"},{"location":"settings/","text":"Settings # clojure-lsp settings are picked up on server start and can be configured via 3 ways: Global configuration project configuration LSP InitializationOptions Project # clojure-lsp will look for project specific settings in a file called .lsp/config.edn . It will search from your project root folder up the directory structure so you can have multiple projects share the same settings. Example: { :cljfmt { :indents { # re \".*\" ns [[ :inner 0 ] [ :inner 1 ]]}} :auto-add-ns-to-new-files? false } Global # For global settings which should work for all the projects using clojure-lsp , you just need to add the same configs to ~/.lsp/config.edn . For an example of a global config.edn , check here . InitializationOptions # This is specific for an client, where it sends on startup, check LSP spec for more information . This is an example how Emacs lsp-mode pass custom information. All settings # name description default source-paths project-local directories to look for clj/cljc/cljs files #{\"src\" \"test\"} ignore-classpath-directories will not consider clojure files within the directories specified by your classpath. This is needed, for instance, if your build puts artifacts into resources or target that you want lsp to ignore. false use-metadata-for-privacy? Whether to use ^:private metadata for refactorings instead of defn- false keep-require-at-start? Whether to keep first require/import at the first line instead of inserting a new line before it when using clean-ns refactoring. false semantic-tokens? Whether to enable LSP semantic tokens server support for syntax highlighting. (Experimental) false show-docs-arity-on-same-line? Whether to keep the arity on the same line of the function on hover, useful for Emacs users. false auto-add-ns-to-new-files? Whether to automatically add the ns form in new blank files. true document-formatting? if true or not present, document formatting is provided. true document-range-formatting? if true or not present, document range formatting is provided. true dependency-scheme How the dependencies should be linked, jar will make urls compatible with java's JarURLConnection. You can have the client make an lsp extension request of clojure/dependencyContents with the jar uri and the server will return the jar entry's contents. Similar to java clients zip cljfmt Used for formatting, json encoded configuration for cljfmt {} project-specs A vector containing a map of key/value pairs, defining how clojure-lsp should find your project classpath Check the default here Lint # clojure-lsp uses clj-kondo to lint the code and retrieve the analysis to make most of features work, make sure you have it properly configured in your .clj-kondo/config.edn file, for more information about available configurations, check the clj-kondo configuration section","title":"Settings"},{"location":"settings/#settings","text":"clojure-lsp settings are picked up on server start and can be configured via 3 ways: Global configuration project configuration LSP InitializationOptions","title":"Settings"},{"location":"settings/#project","text":"clojure-lsp will look for project specific settings in a file called .lsp/config.edn . It will search from your project root folder up the directory structure so you can have multiple projects share the same settings. Example: { :cljfmt { :indents { # re \".*\" ns [[ :inner 0 ] [ :inner 1 ]]}} :auto-add-ns-to-new-files? false }","title":"Project"},{"location":"settings/#global","text":"For global settings which should work for all the projects using clojure-lsp , you just need to add the same configs to ~/.lsp/config.edn . For an example of a global config.edn , check here .","title":"Global"},{"location":"settings/#initializationoptions","text":"This is specific for an client, where it sends on startup, check LSP spec for more information . This is an example how Emacs lsp-mode pass custom information.","title":"InitializationOptions"},{"location":"settings/#all-settings","text":"name description default source-paths project-local directories to look for clj/cljc/cljs files #{\"src\" \"test\"} ignore-classpath-directories will not consider clojure files within the directories specified by your classpath. This is needed, for instance, if your build puts artifacts into resources or target that you want lsp to ignore. false use-metadata-for-privacy? Whether to use ^:private metadata for refactorings instead of defn- false keep-require-at-start? Whether to keep first require/import at the first line instead of inserting a new line before it when using clean-ns refactoring. false semantic-tokens? Whether to enable LSP semantic tokens server support for syntax highlighting. (Experimental) false show-docs-arity-on-same-line? Whether to keep the arity on the same line of the function on hover, useful for Emacs users. false auto-add-ns-to-new-files? Whether to automatically add the ns form in new blank files. true document-formatting? if true or not present, document formatting is provided. true document-range-formatting? if true or not present, document range formatting is provided. true dependency-scheme How the dependencies should be linked, jar will make urls compatible with java's JarURLConnection. You can have the client make an lsp extension request of clojure/dependencyContents with the jar uri and the server will return the jar entry's contents. Similar to java clients zip cljfmt Used for formatting, json encoded configuration for cljfmt {} project-specs A vector containing a map of key/value pairs, defining how clojure-lsp should find your project classpath Check the default here","title":"All settings"},{"location":"settings/#lint","text":"clojure-lsp uses clj-kondo to lint the code and retrieve the analysis to make most of features work, make sure you have it properly configured in your .clj-kondo/config.edn file, for more information about available configurations, check the clj-kondo configuration section","title":"Lint"},{"location":"troubleshooting/","text":"Troubleshooting # It doesn't seem to be working # If you're downloading the release, try running it from the command line, it should start up and start reading stdin. Type {}\\n\\n and you should get something like: $ clojure-lsp {} Apr 12, 2019 7:07:02 AM org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer fireError SEVERE: Missing header Content-Length in input \"{} \" java.lang.IllegalStateException: Missing header Content-Length in input \"{}\"\"\"\" \"\"\" If that is ok, clojure-lsp logs to /tmp/clojure-lsp.*.out , so watch that file and start your editor. LSP Clients also generally have a way to trace server interactions. Turn that on and attach both server and client logs to an issue if it's not obvious what's going on. Go to definition doesn't work # Double check settings # By default clojure-lsp searches src and test for clj* files to read into an index. If the definition lives under a different source dir, you can defiine src-paths in your client's InitializationOptions . It is also important to get your project-root correct in your client otherwise the source paths will not be found. Usually there's an option to search for a project file, so for a lein project you would have your client search for project.clj . Check the logs # There are a couple reasons why go to definition could fail. First, start tailing /tmp/clojure-lsp.*.out . The logs will generally explain why go to definition failed. The definition is still not found # Raise an issue or ask in clojurians slack. Windows # See https://github.com/snoe/clojure-lsp/issues/28 and https://github.com/snoe/clojure-lsp/issues/25 MacOS # In some version of MacOS, Apple restrict the binary to run, to fix that run: xattr -d com.apple.quarantine /path/to/clojure-lsp","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#it-doesnt-seem-to-be-working","text":"If you're downloading the release, try running it from the command line, it should start up and start reading stdin. Type {}\\n\\n and you should get something like: $ clojure-lsp {} Apr 12, 2019 7:07:02 AM org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer fireError SEVERE: Missing header Content-Length in input \"{} \" java.lang.IllegalStateException: Missing header Content-Length in input \"{}\"\"\"\" \"\"\" If that is ok, clojure-lsp logs to /tmp/clojure-lsp.*.out , so watch that file and start your editor. LSP Clients also generally have a way to trace server interactions. Turn that on and attach both server and client logs to an issue if it's not obvious what's going on.","title":"It doesn't seem to be working"},{"location":"troubleshooting/#go-to-definition-doesnt-work","text":"","title":"Go to definition doesn't work"},{"location":"troubleshooting/#double-check-settings","text":"By default clojure-lsp searches src and test for clj* files to read into an index. If the definition lives under a different source dir, you can defiine src-paths in your client's InitializationOptions . It is also important to get your project-root correct in your client otherwise the source paths will not be found. Usually there's an option to search for a project file, so for a lein project you would have your client search for project.clj .","title":"Double check settings"},{"location":"troubleshooting/#check-the-logs","text":"There are a couple reasons why go to definition could fail. First, start tailing /tmp/clojure-lsp.*.out . The logs will generally explain why go to definition failed.","title":"Check the logs"},{"location":"troubleshooting/#the-definition-is-still-not-found","text":"Raise an issue or ask in clojurians slack.","title":"The definition is still not found"},{"location":"troubleshooting/#windows","text":"See https://github.com/snoe/clojure-lsp/issues/28 and https://github.com/snoe/clojure-lsp/issues/25","title":"Windows"},{"location":"troubleshooting/#macos","text":"In some version of MacOS, Apple restrict the binary to run, to fix that run: xattr -d com.apple.quarantine /path/to/clojure-lsp","title":"MacOS"}]}